<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Builder - TTRPG Toolkit</title>
    <link rel="stylesheet" href="file:///android_asset/css/style.css">
</head>
<body>
    <nav class="navbar">
        <h1>TTRPG Toolkit</h1>
        <div class="nav-tabs">
            <a href="index.html">Dashboard</a>
            <a href="dice-roller.html">Dice</a>
            <a href="character-sheet.html">Characters</a>
            <a href="random-generator.html">Generators</a>
            <a href="notes.html">Notes</a>
            <a href="map.html" class="active">Map</a>
            <a href="battle.html">Battle</a>
            <a href="database.html">Database</a>
            <a href="multiplayer.html">Multiplayer</a>
            <a href="settings.html">Settings</a>
        </div>
    </nav>

    <main class="container">
        <!-- Map Controls -->
        <section class="card">
            <h2>Map Builder</h2>
            <div class="map-controls">
                <div class="form-group">
                    <label>Map Name:</label>
                    <input type="text" id="mapName" placeholder="My Adventure Map" class="editable-content">
                </div>
                <div class="map-size-controls">
                    <div class="form-group">
                        <label>Width:</label>
                        <input type="number" id="mapWidth" value="12" min="3" max="50">
                    </div>
                    <div class="form-group">
                        <label>Height:</label>
                        <input type="number" id="mapHeight" value="10" min="3" max="50">
                    </div>
                    <button onclick="createNewMap()" class="btn-primary">New Map</button>
                </div>
            </div>
        </section>

        <!-- Drawing Tools -->
        <section class="card">
            <h2>Drawing Tools</h2>
            <div class="toolbar">
                <div class="tool-group">
                    <label>Tool:</label>
                    <select id="drawingTool">
                        <option value="paint">Paint</option>
                        <option value="erase">Erase</option>
                        <option value="fill">Fill</option>
                        <option value="select">Select</option>
                        <option value="text">Text</option>
                    </select>
                </div>
                <div class="tool-group">
                    <label>Brush Size:</label>
                    <input type="range" id="brushSize" min="1" max="5" value="1">
                    <span id="brushSizeValue">1</span>
                </div>
                <div class="tool-actions">
                    <button onclick="clearMap()" class="btn-danger">Clear Map</button>
                    <button onclick="saveMap()" class="btn-primary">Save Map</button>
                    <button onclick="exportMap()" class="btn-secondary">Export</button>
                </div>
            </div>
        </section>

        <!-- Tile Palette -->
        <section class="card">
            <h2>Tile Palette</h2>
            <div class="tile-palette-controls">
                <div class="tile-editor">
                    <div class="tile-preview" id="currentTile">
                        <div class="tile" style="background-color: #4CAF50;">üå≤</div>
                    </div>
                    <div class="tile-settings">
                        <div class="form-group">
                            <label>Color:</label>
                            <input type="color" id="tileColor" value="#4CAF50">
                        </div>
                        <div class="form-group">
                            <label>Emoji:</label>
                            <div class="emoji-selector">
                                <select id="tileEmojiCategory" onchange="updateEmojiOptions()">
                                    <option value="nature">Nature</option>
                                    <option value="locations">Locations</option>
                                    <option value="adventure">Adventure</option>
                                    <option value="creatures">Creatures</option>
                                    <option value="npc">NPC</option>
                                    <option value="items">Items</option>
                                    <option value="symbols">Symbols</option>
                                </select>
                                <select id="tileEmoji">
                                    <!-- Emojis will be populated by JavaScript -->
                                </select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Custom Text:</label>
                            <input type="text" id="tileText" placeholder="Optional text" maxlength="2">
                        </div>
                        <button onclick="addToPalette()" class="btn-secondary">Add to Palette</button>
                    </div>
                </div>
            </div>
            
            <div class="palette-container">
                <h3>Current Palette</h3>
                <div id="tilePalette" class="tile-palette">
                    <!-- Tiles will be added here -->
                </div>
            </div>
        </section>

        <!-- Map Canvas -->
        <section class="card">
            <div class="card-header">
                <h2>Map Canvas</h2>
                <div class="map-info">
                    <span id="cursorPosition">Hover over map</span>
                    <span id="mapDimensions">12√ó10</span>
                </div>
            </div>
            <div class="map-container">
                <div id="mapGrid" class="map-grid">
                    <!-- Map grid will be generated here -->
                </div>
            </div>
        </section>

        <!-- Saved Maps -->
        <section class="card">
            <div class="card-header">
                <h2>Saved Maps</h2>
                <button onclick="importMap()" class="btn-secondary">Import Map</button>
            </div>
            <div id="savedMaps" class="saved-maps">
                <!-- Saved maps will appear here -->
            </div>
        </section>
    </main>

    <!-- Map Import Modal -->
    <div id="importModal" class="modal" style="display: none;">
        <div class="modal-content">
            <h2>Import Map Data</h2>
            <div class="form-group">
                <label>Paste map JSON data:</label>
                <textarea id="importMapData" placeholder='{"name":"My Map","width":10,"height":8,...}' style="min-height: 200px; font-family: monospace;"></textarea>
            </div>
            <div class="modal-actions">
                <button onclick="processMapImport()" class="btn-primary">Import</button>
                <button onclick="closeImportModal()" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>

    <script src="file:///android_asset/js/main.js"></script>
    <script src="file:///android_asset/js/emojis.js"></script>
    <script>
        let currentMap = {
            id: null,
            name: 'New Map',
            width: 12,
            height: 10,
            tiles: [],
            palette: [],
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };
        
        let maps = JSON.parse(localStorage.getItem('maps') || '[]');
        let selectedTile = { 
            color: '#4CAF50', 
            emoji: 'üå≤',
            text: '',
            category: 'nature'
        };
        let isDrawing = false;
        let currentTool = 'paint';

        // Enhanced default palette with better organization
        const defaultPalette = [
            // Nature
            { color: '#4CAF50', emoji: 'üå≤', category: 'nature', text: '' },
            { color: '#8BC34A', emoji: 'üåø', category: 'nature', text: '' },
            { color: '#795548', emoji: 'ü™®', category: 'nature', text: '' },
            { color: '#2196F3', emoji: 'üåä', category: 'nature', text: '' },
            { color: '#FFC107', emoji: 'üü®', category: 'nature', text: '' },
            
            // Locations
            { color: '#9E9E9E', emoji: 'üè∞', category: 'locations', text: '' },
            { color: '#795548', emoji: 'üõñ', category: 'locations', text: '' },
            { color: '#607D8B', emoji: 'üè†', category: 'locations', text: '' },
            { color: '#3F51B5', emoji: '‚õ™', category: 'locations', text: '' },
            
            // Adventure
            { color: '#FF9800', emoji: '‚öîÔ∏è', category: 'adventure', text: '' },
            { color: '#FF5722', emoji: 'üî•', category: 'adventure', text: '' },
            { color: '#9C27B0', emoji: 'üîÆ', category: 'adventure', text: '' },
            { color: '#E91E63', emoji: 'üíé', category: 'adventure', text: '' },
            
            // Creatures
            { color: '#4CAF50', emoji: 'üêâ', category: 'creatures', text: '' },
            { color: '#FF9800', emoji: 'üê∫', category: 'creatures', text: '' },
            { color: '#795548', emoji: 'üêª', category: 'creatures', text: '' },
            
            // NPC
            { color: '#FFEB3B', emoji: 'üßô', category: 'npc', text: '' },
            { color: '#2196F3', emoji: 'üõ°Ô∏è', category: 'npc', text: '' },
            { color: '#F44336', emoji: 'üëπ', category: 'npc', text: '' }
        ];

        document.addEventListener('DOMContentLoaded', function() {
            initializeMap();
            loadPalette();
            loadSavedMaps();
            setupEventListeners();
            updateEmojiOptions();
        });

        function setupEventListeners() {
            // Update brush size display
            document.getElementById('brushSize').addEventListener('input', function() {
                document.getElementById('brushSizeValue').textContent = this.value;
            });
            
            // Update current tile preview
            document.getElementById('tileColor').addEventListener('input', updateCurrentTile);
            document.getElementById('tileEmoji').addEventListener('change', updateCurrentTile);
            document.getElementById('tileText').addEventListener('input', updateCurrentTile);
            
            // Tool selection
            document.getElementById('drawingTool').addEventListener('change', function() {
                currentTool = this.value;
            });
            
            // Prevent context menu on map
            document.getElementById('mapGrid').addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });
        }

        function initializeMap() {
            currentMap.width = parseInt(document.getElementById('mapWidth').value) || 12;
            currentMap.height = parseInt(document.getElementById('mapHeight').value) || 10;
            currentMap.name = document.getElementById('mapName').value || 'New Map';
            
            // Initialize empty tiles
            currentMap.tiles = [];
            for (let y = 0; y < currentMap.height; y++) {
                const row = [];
                for (let x = 0; x < currentMap.width; x++) {
                    row.push({ 
                        color: '#FFFFFF', 
                        emoji: '', 
                        text: '',
                        category: 'empty'
                    });
                }
                currentMap.tiles.push(row);
            }
            
            renderMap();
            updateMapDimensions();
        }

        function renderMap() {
            const grid = document.getElementById('mapGrid');
            grid.innerHTML = '';
            
            // Set grid template
            grid.style.gridTemplateColumns = `repeat(${currentMap.width}, 50px)`;
            grid.style.gridTemplateRows = `repeat(${currentMap.height}, 50px)`;
            
            for (let y = 0; y < currentMap.height; y++) {
                for (let x = 0; x < currentMap.width; x++) {
                    const tile = document.createElement('div');
                    tile.className = 'map-tile';
                    tile.dataset.x = x;
                    tile.dataset.y = y;
                    
                    const tileData = currentMap.tiles[y][x];
                    tile.style.backgroundColor = tileData.color;
                    
                    // Add content (emoji or text)
                    if (tileData.emoji) {
                        tile.innerHTML = `<div class="tile-emoji">${tileData.emoji}</div>`;
                    } else if (tileData.text) {
                        tile.innerHTML = `<div class="tile-text">${tileData.text}</div>`;
                    } else {
                        tile.innerHTML = '<div class="tile-empty"></div>';
                    }
                    
                    // Add coordinates overlay
                    const coords = document.createElement('div');
                    coords.className = 'tile-coords';
                    coords.textContent = `${x},${y}`;
                    tile.appendChild(coords);
                    
                    // Add event listeners
                    tile.addEventListener('mousedown', handleTileMouseDown);
                    tile.addEventListener('mouseenter', handleTileMouseEnter);
                    tile.addEventListener('mouseup', handleTileMouseUp);
                    tile.addEventListener('touchstart', handleTileTouch);
                    tile.addEventListener('touchmove', handleTileTouch);
                    tile.addEventListener('contextmenu', handleTileRightClick);
                    
                    // Show cursor position on hover
                    tile.addEventListener('mouseenter', function() {
                        document.getElementById('cursorPosition').textContent = `Position: ${x}, ${y}`;
                    });
                    
                    grid.appendChild(tile);
                }
            }
        }

        function handleTileMouseDown(e) {
            e.preventDefault();
            isDrawing = true;
            processTileInteraction(e.target);
        }

        function handleTileMouseEnter(e) {
            if (!isDrawing) return;
            processTileInteraction(e.target);
        }

        function handleTileMouseUp() {
            isDrawing = false;
        }

        function handleTileTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            if (element && element.classList.contains('map-tile')) {
                if (e.type === 'touchstart') {
                    isDrawing = true;
                    processTileInteraction(element);
                } else if (e.type === 'touchmove' && isDrawing) {
                    processTileInteraction(element);
                }
            }
            if (e.type === 'touchend') {
                isDrawing = false;
            }
        }

        function handleTileRightClick(e) {
            e.preventDefault();
            const tile = e.target.closest('.map-tile');
            if (!tile) return;
            
            const x = parseInt(tile.dataset.x);
            const y = parseInt(tile.dataset.y);
            
            // Copy tile to current selection
            const tileData = currentMap.tiles[y][x];
            selectedTile = { ...tileData };
            updateCurrentTile();
            
            TTRPGToolkit.showNotification(`Copied tile from (${x}, ${y})`, 'info');
        }

        function processTileInteraction(tileElement) {
            if (!tileElement || !tileElement.dataset.x) return;
            
            const x = parseInt(tileElement.dataset.x);
            const y = parseInt(tileElement.dataset.y);
            const brushSize = parseInt(document.getElementById('brushSize').value);
            
            switch(currentTool) {
                case 'paint':
                    paintTiles(x, y, brushSize);
                    break;
                case 'erase':
                    eraseTiles(x, y, brushSize);
                    break;
                case 'fill':
                    floodFill(x, y, currentMap.tiles[y][x], selectedTile);
                    break;
                case 'text':
                    addTextToTile(x, y);
                    break;
            }
            
            renderMap();
        }

        function paintTiles(centerX, centerY, brushSize) {
            for (let dy = -brushSize + 1; dy < brushSize; dy++) {
                for (let dx = -brushSize + 1; dx < brushSize; dx++) {
                    const nx = centerX + dx;
                    const ny = centerY + dy;
                    if (nx >= 0 && nx < currentMap.width && ny >= 0 && ny < currentMap.height) {
                        currentMap.tiles[ny][nx] = { ...selectedTile };
                    }
                }
            }
        }

        function eraseTiles(centerX, centerY, brushSize) {
            for (let dy = -brushSize + 1; dy < brushSize; dy++) {
                for (let dx = -brushSize + 1; dx < brushSize; dx++) {
                    const nx = centerX + dx;
                    const ny = centerY + dy;
                    if (nx >= 0 && nx < currentMap.width && ny >= 0 && ny < currentMap.height) {
                        currentMap.tiles[ny][nx] = { 
                            color: '#FFFFFF', 
                            emoji: '', 
                            text: '',
                            category: 'empty'
                        };
                    }
                }
            }
        }

        function floodFill(x, y, targetTile, newTile) {
            if (x < 0 || x >= currentMap.width || y < 0 || y >= currentMap.height) return;
            if (tilesAreEqual(currentMap.tiles[y][x], targetTile)) return;
            if (tilesAreEqual(currentMap.tiles[y][x], newTile)) return;
            
            currentMap.tiles[y][x] = { ...newTile };
            
            floodFill(x + 1, y, targetTile, newTile);
            floodFill(x - 1, y, targetTile, newTile);
            floodFill(x, y + 1, targetTile, newTile);
            floodFill(x, y - 1, targetTile, newTile);
        }

        function tilesAreEqual(tile1, tile2) {
            return tile1.color === tile2.color && 
                   tile1.emoji === tile2.emoji && 
                   tile1.text === tile2.text;
        }

        function addTextToTile(x, y) {
            const text = prompt('Enter text for this tile (max 2 characters):', '');
            if (text !== null && text.trim()) {
                currentMap.tiles[y][x] = {
                    color: selectedTile.color,
                    emoji: '',
                    text: text.trim().substring(0, 2),
                    category: 'text'
                };
            }
        }

        function updateCurrentTile() {
            selectedTile.color = document.getElementById('tileColor').value;
            selectedTile.emoji = document.getElementById('tileEmoji').value;
            selectedTile.text = document.getElementById('tileText').value;
            
            const preview = document.getElementById('currentTile');
            preview.innerHTML = `
                <div class="tile" style="background-color: ${selectedTile.color};">
                    ${selectedTile.emoji || selectedTile.text || '?'}
                </div>
            `;
        }

        function updateEmojiOptions() {
            const category = document.getElementById('tileEmojiCategory').value;
            const emojiSelect = document.getElementById('tileEmoji');
            
            const emojis = TTRPGEmojis[category] || [];
            emojiSelect.innerHTML = emojis.map(emoji => 
                `<option value="${emoji}">${emoji} ${getEmojiName(emoji)}</option>`
            ).join('');
            
            // Update selected tile emoji
            selectedTile.emoji = emojis[0] || '';
            selectedTile.category = category;
            updateCurrentTile();
        }

        function getEmojiName(emoji) {
            // Simple emoji to name mapping
            const emojiNames = {
                'üå≤': 'Tree', 'üåø': 'Grass', 'ü™®': 'Rock', 'üåä': 'Water', 'üè∞': 'Castle',
                'üõñ': 'Hut', 'üè†': 'House', '‚õ™': 'Church', '‚öîÔ∏è': 'Sword', 'üî•': 'Fire',
                'üîÆ': 'Crystal', 'üíé': 'Gem', 'üêâ': 'Dragon', 'üê∫': 'Wolf', 'üêª': 'Bear',
                'üßô': 'Wizard', 'üõ°Ô∏è': 'Shield', 'üëπ': 'Demon'
            };
            return emojiNames[emoji] || '';
        }

        function loadPalette() {
            const palette = document.getElementById('tilePalette');
            palette.innerHTML = '';
            
            // Add default tiles to current map palette
            currentMap.palette = [...defaultPalette];
            
            currentMap.palette.forEach((tile, index) => {
                addPaletteTile(tile, index);
            });
        }

        function addPaletteTile(tile, index) {
            const palette = document.getElementById('tilePalette');
            const paletteTile = document.createElement('div');
            paletteTile.className = 'palette-tile';
            paletteTile.dataset.index = index;
            paletteTile.innerHTML = `
                <div class="tile" style="background-color: ${tile.color};">
                    ${tile.emoji || tile.text || ''}
                </div>
                <button onclick="removeFromPalette(${index})" class="btn-danger">√ó</button>
            `;
            paletteTile.addEventListener('click', () => {
                selectedTile = { ...tile };
                updateCurrentTile();
                document.getElementById('tileColor').value = tile.color;
                document.getElementById('tileText').value = tile.text;
            });
            
            palette.appendChild(paletteTile);
        }

        function addToPalette() {
            if (currentMap.palette.length >= 25) {
                TTRPGToolkit.showNotification('Palette is full (max 25 tiles)', 'warning');
                return;
            }
            
            const newTile = { ...selectedTile };
            currentMap.palette.push(newTile);
            addPaletteTile(newTile, currentMap.palette.length - 1);
            
            TTRPGToolkit.showNotification('Tile added to palette!', 'success');
        }

        function removeFromPalette(index) {
            if (confirm('Remove this tile from palette?')) {
                currentMap.palette.splice(index, 1);
                loadPalette(); // Reload palette
                TTRPGToolkit.showNotification('Tile removed from palette', 'success');
            }
        }

        function createNewMap() {
            if (currentMap.tiles.some(row => row.some(tile => tile.color !== '#FFFFFF')) && 
                !confirm('Create new map? Current unsaved changes will be lost.')) {
                return;
            }
            
            currentMap.id = null;
            initializeMap();
            document.getElementById('mapName').value = 'New Map';
            TTRPGToolkit.showNotification('New map created!', 'success');
        }

        function saveMap() {
            const name = document.getElementById('mapName').value.trim() || 'Unnamed Map';
            currentMap.name = name;
            currentMap.updatedAt = new Date().toISOString();
            
            if (!currentMap.id) {
                currentMap.id = TTRPGToolkit.generateId();
                currentMap.createdAt = new Date().toISOString();
                maps.unshift({ ...currentMap });
            } else {
                const index = maps.findIndex(m => m.id === currentMap.id);
                if (index !== -1) {
                    maps[index] = { ...currentMap };
                } else {
                    maps.unshift({ ...currentMap });
                }
            }
            
            localStorage.setItem('maps', JSON.stringify(maps));
            loadSavedMaps();
            TTRPGToolkit.showNotification('Map saved!', 'success');
        }

        function exportMap() {
            TTRPGToolkit.exportData(currentMap, `map-${currentMap.name.replace(/[^a-z0-9]/gi, '_')}.json`);
            TTRPGToolkit.showNotification('Map exported!', 'success');
        }

        function importMap() {
            document.getElementById('importModal').style.display = 'flex';
            document.getElementById('importMapData').value = '';
        }

        function processMapImport() {
            const importData = document.getElementById('importMapData').value.trim();
            
            if (!importData) {
                TTRPGToolkit.showNotification('Please paste map data!', 'error');
                return;
            }
            
            try {
                const importedMap = JSON.parse(importData);
                
                // Validate map structure
                if (!importedMap.name || !importedMap.width || !importedMap.height || !importedMap.tiles) {
                    throw new Error('Invalid map format');
                }
                
                currentMap = { ...importedMap };
                currentMap.id = TTRPGToolkit.generateId(); // New ID for imported map
                currentMap.updatedAt = new Date().toISOString();
                
                // Update UI
                document.getElementById('mapName').value = currentMap.name;
                document.getElementById('mapWidth').value = currentMap.width;
                document.getElementById('mapHeight').value = currentMap.height;
                
                renderMap();
                updateMapDimensions();
                closeImportModal();
                
                TTRPGToolkit.showNotification('Map imported successfully!', 'success');
            } catch (e) {
                TTRPGToolkit.showNotification('Error importing map: ' + e.message, 'error');
            }
        }

        function closeImportModal() {
            document.getElementById('importModal').style.display = 'none';
        }

        function loadSavedMaps() {
            const container = document.getElementById('savedMaps');
            if (maps.length === 0) {
                container.innerHTML = '<p>No saved maps yet.</p>';
                return;
            }
            
            container.innerHTML = maps.map(map => `
                <div class="saved-map-item" onclick="loadMap('${map.id}')">
                    <div class="map-thumbnail">
                        <div class="thumbnail-grid" style="grid-template-columns: repeat(5, 8px); grid-template-rows: repeat(5, 8px);">
                            ${generateThumbnail(map)}
                        </div>
                    </div>
                    <div class="map-info">
                        <h3>${map.name}</h3>
                        <small>${map.width} √ó ${map.height}</small>
                        <small>${new Date(map.updatedAt).toLocaleDateString()}</small>
                    </div>
                    <div class="map-actions">
                        <button onclick="event.stopPropagation(); exportSpecificMap('${map.id}')" class="btn-secondary">Export</button>
                        <button onclick="event.stopPropagation(); deleteMap('${map.id}')" class="btn-danger">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function generateThumbnail(map) {
            let thumbnail = '';
            const stepX = Math.max(1, Math.floor(map.width / 5));
            const stepY = Math.max(1, Math.floor(map.height / 5));
            
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const tileY = Math.min(y * stepY, map.height - 1);
                    const tileX = Math.min(x * stepX, map.width - 1);
                    const tile = map.tiles[tileY][tileX];
                    thumbnail += `<div style="background-color: ${tile.color};"></div>`;
                }
            }
            return thumbnail;
        }

        function loadMap(id) {
            const map = maps.find(m => m.id === id);
            if (!map) return;
            
            currentMap = JSON.parse(JSON.stringify(map)); // Deep clone
            document.getElementById('mapName').value = currentMap.name;
            document.getElementById('mapWidth').value = currentMap.width;
            document.getElementById('mapHeight').value = currentMap.height;
            
            renderMap();
            updateMapDimensions();
            TTRPGToolkit.showNotification('Map loaded!', 'success');
        }

        function exportSpecificMap(id) {
            const map = maps.find(m => m.id === id);
            if (!map) return;
            
            TTRPGToolkit.exportData(map, `map-${map.name.replace(/[^a-z0-9]/gi, '_')}.json`);
            TTRPGToolkit.showNotification('Map exported!', 'success');
        }

        function deleteMap(id) {
            if (!confirm('Delete this map?')) return;
            
            maps = maps.filter(m => m.id !== id);
            localStorage.setItem('maps', JSON.stringify(maps));
            loadSavedMaps();
            
            if (currentMap.id === id) {
                createNewMap();
            }
            
            TTRPGToolkit.showNotification('Map deleted!', 'success');
        }

        function clearMap() {
            if (!confirm('Clear the entire map?')) return;
            
            for (let y = 0; y < currentMap.height; y++) {
                for (let x = 0; x < currentMap.width; x++) {
                    currentMap.tiles[y][x] = { 
                        color: '#FFFFFF', 
                        emoji: '', 
                        text: '',
                        category: 'empty'
                    };
                }
            }
            renderMap();
            TTRPGToolkit.showNotification('Map cleared!', 'success');
        }

        function updateMapDimensions() {
            document.getElementById('mapDimensions').textContent = `${currentMap.width}√ó${currentMap.height}`;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Number keys for quick tool selection
            if (e.code >= 'Digit1' && e.code <= 'Digit5' && e.ctrlKey) {
                e.preventDefault();
                const tools = ['paint', 'erase', 'fill', 'select', 'text'];
                const toolIndex = parseInt(e.code.replace('Digit', '')) - 1;
                if (tools[toolIndex]) {
                    document.getElementById('drawingTool').value = tools[toolIndex];
                    currentTool = tools[toolIndex];
                    TTRPGToolkit.showNotification(`Tool: ${tools[toolIndex]}`, 'info');
                }
            }
            
            // Space to toggle drawing
            if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                e.preventDefault();
                isDrawing = !isDrawing;
            }
        });
    </script>

    <style>
        .map-controls {
            display: grid;
            gap: 1rem;
        }

        .map-size-controls {
            display: flex;
            gap: 1rem;
            align-items: end;
            flex-wrap: wrap;
        }

        .map-size-controls .form-group {
            flex: 1;
            min-width: 100px;
        }

        .toolbar {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .tool-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-group label {
            margin-bottom: 0;
            white-space: nowrap;
        }

        .tool-actions {
            display: flex;
            gap: 0.5rem;
            margin-left: auto;
        }

        .tile-palette-controls {
            display: grid;
            gap: 1rem;
        }

        .tile-editor {
            display: flex;
            gap: 1rem;
            align-items: start;
            flex-wrap: wrap;
        }

        .tile-preview {
            flex-shrink: 0;
        }

        .tile-settings {
            flex: 1;
            min-width: 250px;
        }

        .emoji-selector {
            display: flex;
            gap: 0.5rem;
        }

        .emoji-selector select {
            flex: 1;
        }

        .tile {
            width: 60px;
            height: 60px;
            border: 2px solid var(--border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .tile:hover {
            transform: scale(1.1);
            border-color: var(--accent);
        }

        .tile-emoji {
            font-size: 1.8rem;
        }

        .tile-text {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--text-primary);
        }

        .palette-container {
            margin-top: 1rem;
        }

        .tile-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 0.5rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            min-height: 80px;
        }

        .palette-tile {
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
        }

        .palette-tile:hover {
            transform: scale(1.1);
        }

        .palette-tile .tile {
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
        }

        .palette-tile button {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            padding: 0;
            border-radius: 50%;
            font-size: 0.8rem;
            display: none;
        }

        .palette-tile:hover button {
            display: block;
        }

        .map-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .map-container {
            overflow: auto;
            max-width: 100%;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            background: var(--bg-secondary);
        }

        .map-grid {
            display: grid;
            gap: 1px;
            background: var(--border);
            border: 1px solid var(--border);
            margin: 0 auto;
        }

        .map-tile {
            width: 50px;
            height: 50px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            position: relative;
            overflow: hidden;
        }

        .map-tile:hover {
            filter: brightness(1.1);
            z-index: 1;
        }

        .tile-coords {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.6rem;
            opacity: 0.3;
            pointer-events: none;
        }

        .map-tile:hover .tile-coords {
            opacity: 0.7;
        }

        .saved-maps {
            display: grid;
            gap: 1rem;
        }

        .saved-map-item {
            display: flex;
            gap: 1rem;
            align-items: center;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid var(--accent);
        }

        .saved-map-item:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .map-thumbnail {
            flex-shrink: 0;
        }

        .thumbnail-grid {
            display: grid;
            gap: 1px;
            background: var(--border);
            border: 1px solid var(--border);
            width: 42px;
            height: 42px;
        }

        .thumbnail-grid div {
            width: 8px;
            height: 8px;
        }

        .map-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .map-info h3 {
            margin: 0;
            color: inherit;
        }

        .map-actions {
            display: flex;
            gap: 0.5rem;
        }

        @media (max-width: 768px) {
            .map-size-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .toolbar {
                flex-direction: column;
                align-items: stretch;
            }
            
            .tool-actions {
                margin-left: 0;
                justify-content: space-between;
            }
            
            .tile-editor {
                flex-direction: column;
            }
            
            .saved-map-item {
                flex-direction: column;
                text-align: center;
            }
            
            .map-actions {
                width: 100%;
            }
            
            .map-actions button {
                flex: 1;
            }
            
            .map-tile {
                width: 40px;
                height: 40px;
                font-size: 1rem;
            }
            
            .emoji-selector {
                flex-direction: column;
            }
        }
    </style>
</body>
</html>
